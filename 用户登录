from flask import Flask, render_template, redirect, url_for, request, flash, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from flask_migrate import Migrate
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime
from functools import wraps
import redis
import os
import random

#========初始化配置==========
app = Flask(__name__)

#1.密钥配置
app.config['SECRET_KEY'] = os.urandom(24)

#2.MYSQL 数据库配置，主库写，从库读
app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://你的MYSQL用户名:你的MYSQL密码@主库IP:3306/product_db?charset=utf8mb4'
#从库，可支持多个从库
app.config['SQLALCHEMY_BINDS'] = {
    'slave1': 'mysql+pymysql://你的MYSQL用户名:你的MYSQL密码@从库1:3306/product_db?charset=utf8mb4',
    'slave2': 'mysql+pymysql://你的MYSQL用户名:你的MYSQL密码@从库2:3306/product_db?charset=utf8mb4'
}

#3.数据库数据连接池设置
app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {
    'pool_size'     : 30,
    'max_overflow'  : 50,
    'pool_recycled' : 3600,
    'pool_pre_ping' : True,
    'echo'          : False
}
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

#初始化组件
db = SQLAlchemy(app)
migrate = Migrate(app, db)            #数据库迁移工具
login_manager = LoginManager(app)
login_manager.login_view = 'login'    #未登录跳转页面

# Redis 配置
redis_client = redis.Redis(
    host = '你的Redis服务器IP',
    port = 6379,
    password = '你的Redis密码',
    db = 0,
    decode_responses = True,
    socket_timeout = 5  #连接超时时间
)

#========数据模型==========
#用户模型
class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(150),unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(256), nullable=False)
    role = db.Column(db.String(20), nullable=False, default='staff', index=True) #角色：店主(owner)、店员(staff)

    #关联出入库记录
    stock_record = db.relationship('StockRecord', backref='operator',lazy=True)

    #设置密码
    def set_password(self, password):
        self.password_hash = generate_password_hash(password, method='pbkdf2:sha256')

    #验证密码
    def check_password(self,password):
        return check_password_hash(self.password_hash, password)
    
    def is_owner(self):
        return self.role =='owner'

#商品模型
class Product(db.Model):
    Product_id = db.Column(db.Integer, primary_key=True)
    barcode = db.Column(db.String(100), unique=True, nullable=False, index=True)  #商品条码
    name = db.Column(db.String(200), nullable=False, index=True)                  #商品名称
    category_id = db.Column(db.Integer, db.ForeignKey('category.id'), nullable=False) #商品类别ID
    specification = db.Column(db.String(100))                                     #规格
    purchase_price = db.Column(db.Float, nullable=False)                          #进价
    selling_price = db.Column(db.Float, nullable=False)                           #售价
    unit = db.Column(db.String(50))                                              #单位
    current_stock = db.Column(db.Integer, nullable=False, default=0)              #当前库存
    min_stock = db.Column(db.Integer, nullable=False, default=0)                  #最低库存预警值
    image_url = db.Column(db.String(500))                                        #商品图片URL
    is_active = db.Column(db.Integer, nullable=False, default=1)                 #是否上架，1=上架，0=下架
    create_time = db.Column(db.DateTime, default=datetime.utcnow)                #创建时间
    update_time = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow) #更新时间

    #关联出入库记录
    stock_records = db.relationship('StockRecord', backref='product', lazy=True, cascade='all, delete-orphan')

    #关联类别
    category = db.relationship('Category', backref=db.backref('products', lazy=True))

    def get_info(self):
        retrun{
            'id': self.id,
            'barcode': self.barcode,
            'name': self.name,
            'category_id': self.category_id,
            'category_name': self.category.name,
            'specification': self.specification,
            'purchase_price': float(self.purchase_price),
            'selling_price': float(self.selling_price),
            'unit': self.unit,
            'current_stock': self.current_stock,
            'min_stock': self.min_stock,
            'image_url': self.image_url,
            'is_active': self.is_active,
            'create_time': self.create_time.strftime('%Y-%m-%d %H:%M:%S'),
            'update_time': self.update_time.strftime('%Y-%m-%d %H:%M:%S')
        }

class StockRecord(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    product_id = db.Column(db.Integer, db.Foreignkey('product.Product_id', ondelate='CASCADE'), nullable=False, index=True) #商品ID
    user_id = db.Column(db.Integer, db.Foreignkey('user.id', ondelate='SET NULL'), nullable=True, index=True)               #操作用户ID
    operation_type = db.Column(db.String(10), nullable=False, index=True)  #操作类型：入库(in)、出库(out)
    quantity = db.Column(db.Integer, nullable=False)                     #数量
    operation_time = db.Column(db.DateTime, nullable=False, default=datetime.now, index=True)          #操作时间
    remark = db.Column(db.Text, default='')

    #格式化输出时间

#=========Flask-Login 回调===========
@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

#========自定义装饰器========
#仅店主可访问
def owner_required(f):
    @login_required
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_owner():
            return redirect(url_for('product_list'))
        return f(*args, **kwargs)
    return decorated_function

#Redis缓存装饰器
def cache_product(expire=3600):
    """缓存商品详细，默认1小时过期"""
    def decorator(f):
        @wraps(f)
        def wrapper(product_id, *args, **kwargs):
            cache_key = f"product_detail:{product_id}"
            cached_data = redis_client.get(cache_key)
            if cached_data:
                return jsonify({'code': 200, 'data': eval(cached_data)}), 200
            result = f(product_id, *args, **kwargs)
            if result[0]['code'] == 200:
                redis_client.setex(cache_key, expire, str(result[0]['data']))
            return result
        return wrapper
    return decorator